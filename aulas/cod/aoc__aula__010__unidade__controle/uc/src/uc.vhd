-- Project generated by script.
-- Date: Ter,02/07/2013-22:42:14
-- Author: rogerio
-- Comments: Entity Description: uc.
 
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_arith.all;

-- print messages.
use std.textio.all;
use ieee.std_logic_textio.all;

entity uc is
	port (ir: in std_logic_vector(31 downto 0); op_code, funct: out std_logic_vector(5 downto 0); op_mode: out std_logic_vector(2 downto 0); rs, rt, rd, shamt: out std_logic_vector(4 downto 0); imm: out std_logic_vector(15 downto 0); address: out std_logic_vector(25 downto 0));
end uc;
 
architecture funcional of uc is
-- Campos do formato de instrução.
-- opcode  := ir(31 downto 26)
-- rs      := ir(25 downto 21);
-- rt      := ir(20 downto 16);
-- rd      := ir(15 downto 11);
-- shamt   := ir(10 downto  6);
-- imm     := ir(15 downto  0);
-- address := ir(25 downto  0); 

-- Formato R: 000, Formato I: 001, Formato J: 010.

-- registradores.

type reg_type is record
			 reg_cod: integer;
             reg_name: string;
             reg_desc: string;
end record;
        
		--  The input patterns are applied (injected) to the inputs of the entity under test.
		type registers_array is array (natural range <>) of reg_type;
		-- Test cases.
		constant registers : registers_array :=
		(
            (0, "$zero", "$0 constante 0"),
            (1, "$at", "$1 reserved for assembler"),
            (2, "$v0", "-- $2   return value"),
            (3, "$v1", "-- $3   return value"),
            (4, "$a0", "-- $4   argument"),
            (5, "$a1", "-- $5   argument"),
            (6, "$a2", "-- $6   argument"),
            (7, "$a3", "-- $7   argument"),
            (8, "$t0", "-- $8   temporary"),
            (9, "$t1", "-- $9   temporary"),
            (10,"$t2", "-- $10  temporary"),
            (11,"$t3", "-- $11  temporary"),
            (12,"$t4", "-- $12  temporary"),
            (13,"$t5", "-- $13  temporary"),
            (14,"$t6", "-- $14  temporary"),
            (15,"$t7", "-- $15  temporary"),
            (16,"$s0", "-- $16  saved temporary"),
            (17,"$s1", "-- $17  saved temporary"),
            (18,"$s2", "-- $18  saved temporary"),
            (19,"$s3", "-- $19  saved temporary"),
            (20,"$s4", "-- $20  saved temporary"),
            (21,"$s5", "-- $21  saved temporary"),
            (22,"$s6", "-- $22  saved temporary"),
            (23,"$s7", "-- $23  saved temporary"),
            (24,"$t8", "-- $24  temporary"),
            (25,"$t9", "-- $25  temporary"),
            (26,"$k0", "-- $26  reserved for OS"),
            (27,"$k1", "-- $27  reserved for OS"),
            (28,"$gp", "-- $28  global pointer"),
            (29,"$sp", "-- $29  stack pointer"),
            (30,"$fp", "-- $30  frame pointer"),
            (31,"$ra",  "-- $31  return address")			
		);
begin
  -- Commands.
  process (ir)
  -- imprimir a instrução.
  variable inst_out: line;
  begin
    -- Testa qual opcode para descobrir o formato.
    case ir(31 downto 26) is
        when "000000" => -- register instruction format. 
            op_mode <= "000";
            case ir(5 downto 0) is
                when "100000" => -- add
                    -- Read the instruction field
                    op_code <= ir(31 downto 26);
                    rs      <= ir(25 downto 21);
                    rt      <= ir(20 downto 16);
                    rd      <= ir(15 downto 11);
                    shamt   <= "00000";
                    funct   <= ir(5 downto 0);
                    imm     <= "0000000000000000";
                    address <= "00000000000000000000000000";
                    
                    write(inst_out, string'("add"));
                    write(inst_out, string'(" "));
                    write(inst_out, registers(conv_integer(rd,32)).reg_name);
                    write(inst_out, string'(", "));
                    write(inst_out, registers(conv_integer(rs,32)).reg_name);
                    write(inst_out, string'(", "));
                    write(inst_out, registers(conv_integer(rt,32)).reg_name);
                    writeline(output, inst_out);
                    
                    
                    
                when others   => -- outros funct não previstos.
            end case;
        when others   => -- outros não previstos.    
    end case;
  end process;      
end funcional;

